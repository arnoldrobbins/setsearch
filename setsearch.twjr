\input texinfo   @c -*-texinfo-*-
@c vim: filetype=texinfo tabstop=4 shiftwidth=4
@c %**start of header (This is for running Texinfo on a region.)
@setfilename setsearch.info
@settitle Efficient Searching of Large Character Sets
@c %**end of header (This is for running Texinfo on a region.)

@c Change how xref titles are quoted.
@dquotexrefs
@ifclear FORPRINT
@pdflinkcolor
@urllinkcolor
@hideurls
@end ifclear


@c The following information should be updated here only!
@c This sets the edition of the document.

@c These apply across the board.
@set UPDATE-MONTH October, 2024
@set EDITION 0.6

@set TITLE Efficient Searching of Large Character Sets
@set SHORTTITLE Searching Character Sets

@iftex
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end iftex
@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifhtml
@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set APPENDIX major node
@set SECTION minor node
@set SUBSECTION node
@end ifinfo
@ifdocbook
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifdocbook

@c some special symbols
@ifnottex
@macro ii{text}
@i{\text\}
@end macro
@end ifnottex

@c merge the function and variable indexes into the concept index
@c do so without the code font, and in the index entries do the
@c font management ourselves.  Also merge in the chunk definition
@c and reference entries, which jrweave creates for us.
@ifnothtml
@synindex fn cp
@synindex vr cp
@synindex cd cp
@synindex cr cp
@end ifnothtml

@c If "finalout" is commented out, the printed output will show
@c black boxes that mark lines that are too long.  Thus, it is
@c unwise to comment it out when running a master in case there are
@c overfulls which are deemed okay.

@iftex
@c @finalout
@end iftex

@copying
@docbook
<para>Published by:</para>

<literallayout class="normal">Arnold David Robbins
P.O. Box 354
Nof Ayalon 9978500
ISRAEL
Email: <email>arnold@@skeeve.com</email>
URL: <ulink url="https://www.skeeve.com/">https://www.skeeve.com/</ulink></literallayout>

<literallayout class="normal">Copyright &copy; 2024
Arnold David Robbins
All Rights Reserved.</literallayout>
@end docbook

@ifnotdocbook
Copyright @copyright{} 2024 @*
Arnold David Robbins @*
All Rights Reserved.
@end ifnotdocbook
@sp 1
The setsearch program is copyright
@copyright{} 2024 by Arnold David Robbins.
@c It is published under the conditions of a BSD license yet to be determined.
Not for publication, yet.
@sp 2
This is Edition @value{EDITION} of @cite{@value{TITLE}}.
@end copying

@c Uncomment this for the release.  Leaving it off saves paper
@c during editing and review.
@c @setchapternewpage odd

@c Uncomment this if it's ever printed as a real book(let).
@c @shorttitlepage @value{SHORTTITLE}

@titlepage
@title @value{TITLE}
@subtitle @value{UPDATE-MONTH}
@author Arnold David Robbins

@ifnotdocbook
@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
Published by:
@sp 1
Arnold David Robbins @*
P.O. Box 354 @*
Nof Ayalon 9978500 @*
ISRAEL @*
Email: @EMAIL{arnold@@skeeve.com,arnold AT skeeve.com} @*
URL: @url{https://www.skeeve.com/} @*

@insertcopying
@end ifnotdocbook
@end titlepage

@set DRAFT

@iftex
@headings off
@evenheading @thispage @| @value{DRAFT} @| @strong{@value{SHORTTITLE}}
@oddheading  @strong{@thischapter} @| @value{DRAFT} @| @thispage
@end iftex

@ifnottex
@ifnotdocbook
@ifnotxml
@node Top
@top General Introduction
@c Preface node should come right after the Top
@c node, in `unnumbered' sections, then the introductory chapter.
@c Licensing nodes are appendices, they're not central to TexiWebJr.

This file documents @code{setsearch}, a set of functions that accept
a wide character value and search a defined set of characters to
see if the value is in the set.  It is intended for use within
a regular expression matching library.

@insertcopying
@end ifnotxml
@end ifnotdocbook
@end ifnottex

@menu
@detailmenu
@end detailmenu
@end menu

@c @summarycontents
@contents

@c Add these to the menu if they ever get included.
@c @node Foreword
@c @unnumbered Foreword

@node Preface
@unnumbered Preface

This @value{DOCUMENT} documents @code{setsearch}, a set of functions that accept
a wide character value and search a defined set of characters to
see if the value is in the set.  It is intended for use within
a regular expression matching library.

@menu
* Audience::                    Who should read this @value{DOCUMENT}.
* Overview::                    An overview of the @value{DOCUMENT}.
* Conventions::                 Typographical conventions.
* Acknowledgements::            Acknowledgements.
@end menu

@node Audience
@unnumberedsec Intended Audience

If you're interested in one way to search bracket expressions for
a matching character value when using very large character sets
(such as Unicode), you should read this @value{DOCUMENT}.

@node Conventions
@unnumberedsec Typographical Conventions

@c Copied mostly verbatim from the gawk manual.

@cindex Texinfo document formatting language
This @value{DOCUMENT} is written in an enhanced version of
@uref{https://www.gnu.org/software/texinfo/, Texinfo},
the GNU documentation formatting language.
A single Texinfo source file is used to produce both the printed and online
versions of a program's documentation.
@ifnotinfo
Because of this, the typographical conventions
are slightly different than in other books you may have read.
@end ifnotinfo

Examples you would type at the command-line are preceded by the common
shell primary and secondary prompts, @samp{$} and @samp{>}.  Input that
you type is shown @kbd{like this}.  Output from the command is preceded
by the glyph ``@print{}''.  This typically represents the command's
standard output.  Error messages, and other output on the command's
standard error, are preceded by the glyph ``@error{}''.  For example:

@example
$ @kbd{echo hi on stdout}
@print{} hi on stdout
$ @kbd{echo hello on stderr 1>&2}
@error{} hello on stderr
@end example

@ifnotinfo
In the text, command names appear in @code{this font}, while code segments
appear in the same font and quoted, @samp{like this}.  Options look
like this: @option{-f}.  Some things are emphasized @emph{like this},
and if a point needs to be made strongly, it is done @strong{like this}.
The first occurrence of a new term is usually its @dfn{definition} and
appears in the same font as the previous occurrence of ``definition''
in this sentence.  Finally, file names are indicated like this:
@file{/path/to/our/file}.
@end ifnotinfo

@node Acknowledgements
@unnumberedsec Acknowledgements

Thanks to Mike Haertel for his feedback, and for giving me the
opportunity to write this bit of code.

@node Introduction
@chapter Introduction

In the fall of 2023, Mike Haertel started writing a new regular expression library,
@code{minrx}, with the aim of eventually replacing the matchers in use by GNU Awk
(@command{gawk}).  The initial version is in C++; it will eventually be translated
to C for portability. As of December 2023, it's working fully, with the exception
of matching multibyte-encoded characters.

As part of the discussion between Mike and myself, I offered a rough draft of a
data structure to use for quickly seeing if a character matches a @dfn{bracket expression},
which is a construct used within regular expressions to represent sets of different
kinds of characters to be matched.

The ideas for this data structure and how to use it had been bouncing around in
my head for some time. This @value{DOCUMENT} presents the design and implementation
of a sublibrary (so to speak) for dealing with bracket expressions.

The machine-readable files are available from GitHub. The steps
necessary to get them are:

@example
git clone https://github.com/arnoldrobbins/setsearch
cd setsearch
vim jrweave jrtangle    # or emacs :-). Set the path to gawk
make
@end example

@noindent
In order to format the document,
you will need to have @TeX{} and Texinfo installed,
including @command{texi2pdf}.  Or you can ask me for
a PDF, if necessary.

@node API
@chapter The C API

The routines here will eventually be called from C.  I've chosen to just
write everything in C from the beginning, since the ideas are pretty straightforward
and I don't need any of the fancy capabilities of C++.

API design needs careful thought. In this case, we have to take into account
how these routines will be used by a regular expression matcher. Here is
the header file with the declarations.  I've chosen to keep the data structures
opaque, and to provide routines that manipulate them and return results.

@(bracketexpr.h@)=
#ifndef BRACKET_EXPR_H
#define BRACKET_EXPR_H  1

@<Copyright statement@>

#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _bracket_expr BRACKET_EXPR;

enum setsearch_flags {
	SS_ESCAPES_ALLOWED	= 0x01,
	SS_IGNORE_CASE		= 0x02,
	SS_NO_NEWLINES		= 0x04,
	SS_DOT			= 0x08,
};

const BRACKET_EXPR *bracket_expr_create(const char *expr,
                                        size_t expr_len,
                                        const char **endp,
                                        mbstate_t *mbsp,
                                        int flags,
                                        size_t mb_cur_max,
                                        char *errbuf,
                                        size_t errbuf_size);

bool bracket_expr_match(const BRACKET_EXPR *brack_expr,
                        int32_t the_char, bool isvalid);

bool bracket_expr_free(const BRACKET_EXPR *brack_expr);

void bracket_expr_dump(const BRACKET_EXPR *brack_expr, FILE *fp);

#ifdef __cplusplus
}
#endif
#endif // BRACKET_EXPR_H
@

The routines and what they do are as follows:

@table @code
@item const BRACKET_EXPR *bracket_expr_create(const char *expr,
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ size_t expr_len,
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ const char **endp,
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ mbstate_t *mbsp,
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ int flags,
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ size_t mb_cur_max,
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ char *errbuf,
@itemx @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ size_t errbuf_size)
This function parses the bracket expression, and if successful, returns
a pointer to an opaque @code{BRACKET_EXPR} structure to be used by other
routines. Upon failure, it returns @code{NULL}.  The parameters are:

@c nested table
@table @code
@item const char *expr
A pointer to the opening @samp{[} of the bracket expression.
Although it'd be nice if we could mandate that @code{expr} be a NUL-terminated standard C string,
we can't. The GNU ``no arbitrary limits'' principle requires that even
something like @samp{[abc\000123]} should work; NUL bytes can
be included in the regexp and matched.

@item size_t expr_len
How many bytes are available to be processed starting
from @code{expr}.

@item const char **endp
A pointer to a pointer. Upon success, @code{*end} is set to point to
the byte immediately following the closing @samp{]}.

@item mbstate_t mbsp
A pointer to the @code{mbstate_t} object being used to parse the
regular expression.  It is updated as the bracket expression is parsed.

@item int flags
The bitwise-OR of one or more of the flags defined in the header.
@strong{FIXME:} Go through them here.

@item size_t mb_cur_max
The value of @code{MB_CUR_MAX}.  We don't use that constant
directly since on GLIBC systems (at least) it hides a function call.

@item char *errbuf
The address of a buffer into which @code{bracket_expr_create()} will
write a message upon failure.
The message will
already have been translated by @code{gettext()}.

@item size_t errbuf_size
The size of @code{errbuf}'s buffer.
@end table
@c end nested table

@item bool bracket_expr_match(const BRACKET_EXPR *brack_expr, int32_t the_char, bool isvalid)
Return @code{true} if @code{the_char} is found in the set described by
@code{brack_expr}, @code{false} otherwise. @code{isvalid} indicates the character
is valid in the current character set. This can be determined from the return
value of @code{mbrtowc()}.

@item bool bracket_expr_free(const BRACKET_EXPR *brack_expr)
Release the storage used by @code{brack_expr}. Return @code{false}
if @code{brack_expr} is @code{NULL}, @code{true} otherwise.

@item void bracket_expr_dump(const BRACKET_EXPR *brack_expr, FILE *fp)
Dump the internal data structures to the given open file.
I could instead have provided a variable @samp{extern FILE *brack_expr_fp}
initialized to @code{stderr}, but that isn't thread-safe; it's better
to not depend upon global variables.
@end table

The API of @code{bracket_expr_create()} is intended to be easy to
use by the compilation phase of regexp matcher, which has to
work its way through the entire text of the regexp.
As soon as @samp{[} is seen, the compilation phase can call
@code{bracket_expr_create()}, and then continue scanning at @code{*end}.

The source code starts out with a copyright statement and the usual includes,
followed by the other things one might expect:

@(bracketexpr.c@)=
@<Copyright statement@>

@<includes@>
#include "bracketexpr.h"	// for the BRACKET_EXPR typedef
@<deal with @code{gettext()}@>

@<data structures@>
@<global data@>
@<helper functions@>
@<API functions@>
@

To get it out of the way, here is the copyright statement.

@<Copyright statement@>=
// Copyright (C) 2024, Arnold David Robbins.
// All rights reserved.  Not for redistribution (yet...).
@

We include the standard header files that we'll need:

@<includes@>=
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <wctype.h>
#include <locale.h>
@

Since we want the error messages to be translatable,
we have deal with @code{gettext()}:

@<deal with @code{gettext()}@>=
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef HAVE_GETTEXT_H
#include "gettext.h"
#define _(x) gettext(x)
#else
#define _(x) x
#endif
@

@node The Data Structures
@chapter The Data Structures

A single item in the set is represented by
a set item:

@<data structures@>=
typedef struct set_item {
	enum set_item_type {
		CTYPE_ITEM,
		RANGE_ITEM,
	} item_type;
	union {
		struct _ctype {
			wctype_t    wtype;
			const char *type_name;
		} c;
		struct _range {
			int32_t start, end;
		} r;
	} u;
} set_item;
#define wtype		u.c.wtype
#define type_name	u.c.type_name
#define start		u.r.start
#define end			u.r.end
@

A @code{set_item} holds one of two things:

@itemize @bullet
@item Information needed for use with the @code{iswctype()} function.
This consists of a value of type @code{wctype_t}, and a pointer to
a string representing the ctype.

@item A range, such as @code{[a-z]}.
Single characters that
aren't contiguous with others are placed in a range where
@code{start} and @code{end} are set to the same value.
@end itemize

The full bracket expression holds a dynamically allocated
array of @code{set_items}, plus what's needed for managing
the memory:

@<data structures@>=
struct _bracket_expr {
	bool	complemented;		// For [^...] sets
	bool	escapes_allowed;	// For dumping
	bool	ignore_case;		// For dumping
	bool    no_newlines;		// For dumping
	size_t  mb_cur_max;         // Needed for parsing and matching
	size_t	nelems;				// Number of elements in use
	size_t	allocated;			// Number allocated.
	set_item *items;			// Array of items
};
@

The @code{escapes_allowed}, @code{ignore_case}, and @code{no_newlines}
members are not strictly necessary. But they are useful when dumping
the data in that it tells us how the bracket expression was constructed.

@node The Easy Stuff
@chapter The Easy Functions

Let's get the easier functions out of the way.
A fundamental assumption is that the array of items
is sorted and uniqued. In addition, all @code{CTYPE_ITEM}s
are at the front of the array, so that they can be tested
first.

@<API functions@>=
/* bracket_expr_match --- see if a character matches the expression */

bool
bracket_expr_match(const BRACKET_EXPR *brack_expr, int32_t the_char, bool isvalid)
{
	if (brack_expr == NULL)
		return false;

	// invalid characters never match a bracket expression
	if (! isvalid)
		return false;

	if (the_char == L'\n' && brack_expr->no_newlines && brack_expr->complemented)
		return false;

	bool found = is_found(brack_expr, the_char);
	if (brack_expr->complemented)
		found = ! found;		// reverse sense of the match

	return found;
}

/* bracket_expr_free --- free all storage */

bool
bracket_expr_free(const BRACKET_EXPR *brack_expr)
{
	if (brack_expr == NULL)
		return false;

	for (int i = 0; i < brack_expr->nelems; i++) {
		if (brack_expr->items[i].item_type == CTYPE_ITEM)
			free((void *) brack_expr->items[i].type_name);
		else
			break;
	}

	free((void *) brack_expr->items);
	free((void *) brack_expr);

	return true;
}
@

@node Searching
@section Searching For A Character

The actual searching is separate from the ``is complemented'' test to
keep things simple.

@<helper functions@>=
@<item comparison functions@>

/* is_found --- return true if the character is found */

static bool
is_found(const BRACKET_EXPR *brack_expr, int32_t the_char)
{
	set_item *set = brack_expr->items;
	int i;

	@<Search for a @code{CTYPE_ITEM}@>
	@<Search for a @code{RANGE_ITEM}@>
}
@

The @code{CTYPE_ITEM}s are checked first, since
each one can match multiple characters with a single function call:

@<Search for a @code{CTYPE_ITEM}@>=
for (i = 0; i < brack_expr->nelems; i++) {
	// linear search of ctype items
	if (set[i].item_type == RANGE_ITEM)
		break;

	assert(set[i].item_type == CTYPE_ITEM);
	if (iswctype(the_char, set[i].wtype))
		return true;
}

if (i >= brack_expr->nelems)
	return false;
@

Searching through the range items has a wrinkle or two.
After running some tests,
comparing GNU @code{dfa}, GNU @code{regex}, the One True Awk, GoAwk, MKS Awk,
and Busybox Awk, we came to the following conclusions as to the behavior that
we wanted:

@itemize @bullet
@item
In a single-byte locale, the input character is always searched
for, even if it's not valid in the current character set.

@item
In a multibyte locale, the situation is messier:

@c nested list
@itemize ---
@item
An invalid character can be given inside a character set, e.g. @code{[a\376%]}.
(This is a parse time condition.)
However, that same value in the input does not match.
(This is a search time condition.)

@item
An invalid character does not match an inverted character set.
E.g., @code{'\376'} does not match @code{[^a-z]}.

@item
An invalid character does not match within a range even if
numerically it's within the range. (Search time condition.)
If one or both of the endpoints within the range are invalid,
it's an invalid set. (Parse time condition.)
@end itemize
@c end nested list
@end itemize

@noindent
We will deal with the parse time conditions later when we build
the bracket expression.

@<Search for a @code{RANGE_ITEM}@>=
assert(set[i].item_type == RANGE_ITEM);

// binary search to see if we have it
set_item *found;
set_item key;
key.item_type = RANGE_ITEM;
key.start = key.end = the_char;

found = bsearch(& key, set + i, brack_expr->nelems - i,
				sizeof(set_item), item_compare_for_searching);

return found != NULL;
@

We need the header file for assertions:

@<includes@>=
#include <assert.h>
@

We need two comparison functions: one for use by @code{bsearch()} and
a different one for use by by @code{qsort()}.  We
want @code{CTYPE_ITEM}s to sort to the front of the list.  For sorting,
we sort the @code{RANGE_ITEM}s based on their @code{start} value.
For searching, we have to compare with the value in @code{key},
and we will only be looking at @code{RANGE_ITEM}s.

The comparisons are fundamentally different. When sorting,
we're comparing array elements against each other. When
searching, we compare elements one at a time against a key.
The sorting comparison is more elaborate:

@<item comparison functions@>=
/* item_compare_for_sorting --- compare two set_items */

static int
item_compare_for_sorting(const void *l, const void *r)
{
	set_item *left = (set_item *) l;
	set_item *right = (set_item *) r;

	if (left->item_type == CTYPE_ITEM && right->item_type == CTYPE_ITEM) {
		return left->wtype - right->wtype;
	} else if (left->item_type == CTYPE_ITEM && right->item_type == RANGE_ITEM) {
		return -1;
	} else if (left->item_type == RANGE_ITEM && right->item_type == CTYPE_ITEM) {
		return +1;
	} else {
		assert(left->item_type == RANGE_ITEM && right->item_type == RANGE_ITEM);
		return left->start - right->start;
	}
}
@

The searching function is simpler.  POSIX tells us that the first
argument is the key and the second is the array element being
compared.

@<item comparison functions@>=
/* item_compare_for_searching --- compare two set_items */

static int
item_compare_for_searching(const void *k, const void *e)
{
	set_item *thekey = (set_item *) k;
	set_item *elem = (set_item *) e;

	assert(thekey->item_type == RANGE_ITEM && elem->item_type == RANGE_ITEM);

	if (elem->start <= thekey->start && thekey->start <= elem->end)
		return 0;	// found it
	else if (thekey->end < elem->start)
		return -1;
	else {
		assert(thekey->start > elem->end);
		return 1;
	}
}
@

@node Printing
@section Printing The Data Structure

Printing the data is straightforward.

@<API functions@>=
/* bracket_expr_dump --- dump out the data structures */

void
bracket_expr_dump(const BRACKET_EXPR *brack_expr, FILE *fp)
{
	static const char *boolval[] = {
		"false",
		"true",
	};

	if (brack_expr == NULL || fp == NULL)
		return;

	fprintf(fp, "complemented = %s\n", boolval[!! brack_expr->complemented]);
	fprintf(fp, "escapes_allowed = %s\n", boolval[!! brack_expr->escapes_allowed]);
	fprintf(fp, "ignore_case = %s\n", boolval[!! brack_expr->ignore_case]);
	fprintf(fp, "no_newlines = %s\n", boolval[!! brack_expr->no_newlines]);
	fprintf(fp, "mb_cur_max = %lu\n", brack_expr->mb_cur_max);

	set_item *set = brack_expr->items;
	for (int i = 0; i < brack_expr->nelems; i++) {
		if (set[i].item_type == CTYPE_ITEM) {
			fprintf(fp, "%3d. CTYPE: [:%s:]\n", i, set[i].type_name);
			continue;
		}
		assert(set[i].item_type == RANGE_ITEM);
		fprintf(fp, "%3d. RANGE: start = L'%lc', end = L'%lc'\n",
			i, set[i].start, set[i].end);
	}
	fflush(fp);
}
@

@node Parsing the set
@chapter Parsing The Set

Now that we've seen how the data structures are used
once they've been built, we get to the hard part, which
is transforming the text of the bracket expression
into the data structure.

For safety's sake, we work through the bracket expression
one wide character at a time. As we do so, we have to take
into account that characters may be escaped with @samp{\}.
We also have to be able to peek ahead in the stream one or two
wide characters.  To that end, there are three wide characters
used in this code:

@table @code
@item a_wchar
This is the next physical wide character to come out
of the input byte string. It might be @samp{\} or something
else.

@item cur_wchar
This is the current wide character, which may have been
escaped. If it was, @code{escaped} will be @code{true}.

@item next_wchar
This is the next wide character, found via lookahead.
@end table

@<API functions@>=
/* bracket_expr_create --- parse the expression and build a BRACKET_EXPR */

const BRACKET_EXPR *bracket_expr_create(const char *expr,
                                        size_t expr_len,
                                        const char **endp,
                                        mbstate_t *mbsp,
                                        int flags,
                                        size_t mb_cur_max,
                                        char *errbuf,
                                        size_t errbuf_size)
{
	@<variables for parsing@>
	@<init variables for parsing@>
	bool ignore_case = (flags & SS_IGNORE_CASE) != 0;
	bool escapes_allowed = (flags & SS_ESCAPES_ALLOWED) != 0;
	bool no_newlines = (flags & SS_NO_NEWLINES) != 0;

	if (expr == NULL || endp == NULL) {
		snprintf(errbuf, errbuf_size, _("bad pointers received"));
		return NULL;
	}
	@<allocate initial data@>

	@<get a wide character@>
	if (a_wchar == L'.' && (flags & SS_DOT) != 0) {
		if (no_newlines) {
			if (! push_range_item(bracket_expr, ignore_case, 0, L'\n' - 1, errbuf, errbuf_size))
				goto fail;
			if (! push_range_item(bracket_expr, ignore_case, L'\n' + 1, 0x110000 - 1, errbuf, errbuf_size))
				goto fail;
		} else {
			if (! push_range_item(bracket_expr, ignore_case, 0, 0x110000 - 1, errbuf, errbuf_size))
				goto fail;
		}
		goto done;
	}

	if (a_wchar != L'[') {
		snprintf(errbuf, errbuf_size, _("bad bracket expression"));
		return NULL;
	}

	set_item *items = bracket_expr->items;

	// main loop:
	while (cp < last) {
		@<get current wide character@>
		if (at_first_char && cur_wchar == L'^') {
			bracket_expr->complemented = true;

			// get the next character and then fall through
			@<get current wide character@>
		}

		if (! at_first_char && ! escaped && cur_wchar == L']')
			break;		// all done

		at_first_char = false;

		if (escaped)
			goto check_for_range;

		if (cur_wchar == L'[') {
			@<peek at next wide character@>
			if (wcschr(L":=.", next_wchar) == NULL)
				goto check_for_range_2;

			@<get current wide character@>
			@<process @code{[:...:]} items@>
			@<process @code{[=...=]} items@>
			@<process @code{[.X.]} items@>
		}

	check_for_range:

		@<peek at next wide character@>

	check_for_range_2:
		first_range_char_invalid = invalid;

		if (next_wchar == L'-') {
			wint_t first_wc, second_wc;

			first_wc = cur_wchar;
			// consume the '-'
			cp += n;

			// and get the second character
			@<peek at next wide character@>

			if (first_range_char_invalid || invalid /* 2nd range char */) {
				snprintf(errbuf, errbuf_size, _("invalid start or end of range character"));
				return NULL;
			}

			if (next_wchar == L']') {
				// '-' was before terminating ']', treat literally
				if (! push_wc(first_wc, errbuf, errbuf_size))
					goto fail;
				cur_wchar = L'-';
				goto push_wchar;
			} else {
				@<get current wide character@>
			}

			second_wc = cur_wchar;
			if (second_wc < first_wc) {
					snprintf(errbuf, errbuf_size, _("invalid range L'%lc' - L'%lc'"), first_wc, second_wc);
					return NULL;
			}
			if (! push_range_item(bracket_expr, ignore_case, first_wc, second_wc, errbuf, errbuf_size))
				goto fail;

			continue;
		}

	push_wchar:
		// push cur_wchar onto wide character list
		if (! push_wc(cur_wchar, errbuf, errbuf_size))
			goto fail;
	}

	if (cur_wchar != L']') {
		snprintf(errbuf, errbuf_size, _("no closing bracket"));
		goto fail;
	}

done:
	@<sort wide character list@>
	@<condense wide character list into @code{RANGE_ITEM}s@>
	@<condense final array of @code{set_item}s@>

	*endp = cp;

	return bracket_expr;

fail:
	bracket_expr_free(bracket_expr);
	return NULL;
}
@

Here are the variables we need when working through
the expression using wide characters.

@<variables for parsing@>=
wint_t a_wchar, cur_wchar, next_wchar;
size_t n;
const char *cp, *last;
bool at_first_char = true;
bool escaped = false;
bool invalid = false;
bool first_range_char_invalid = false;
@

Initialization is obvious:

@<init variables for parsing@>=
cp = expr;
last = expr + expr_len;
@

We need to get the current wide character and
advance @code{cp}. In so doing, we have to handle
escaped characters as well:

@<get current wide character@>=
@<get a wide character@>
if (escapes_allowed && a_wchar == L'\\') {
	@<get a wide character@>
	cur_wchar = a_wchar;
	at_first_char = false;
	escaped = true;
} else {
	escaped = false;
	cur_wchar = a_wchar;
}
@

This actually gets the next wide character:

@<get a wide character@>=
n = mbrtowc(& a_wchar, cp, mb_cur_max, mbsp);
if (n == (size_t) -1 || n == (size_t) -2) {
	// treat bad bytes as individual code points,
	// even if invalid and just skip over them.
	a_wchar = *cp & 0xFF;
	if (mb_cur_max > 1)
		invalid = true;
	n = 1;
	// after an invalid conversion, reinitialize *mbsp
	memset(mbsp, 0, sizeof(*mbsp));
}
cp += n;
@

And we also need to be able to peek ahead:

@<peek at next wide character@>=
n = mbrtowc(& next_wchar, cp, mb_cur_max, mbsp);
if (n == (size_t) -1 || n == (size_t) -2) {
	// here too, treat bad bytes as individual code points,
	// even if invalid and just skip over them.
	a_wchar = *cp & 0xFF;
	if (mb_cur_max > 1)
		invalid = true;
	n = 1;
	// after an invalid conversion, reinitialize *mbsp
	memset(mbsp, 0, sizeof(*mbsp));
}
// since we are peeking, we do NOT advance cp
@

Allocating the various bits of data is the usual @code{malloc()},
check for errors, and @code{memset()} to zero:

@<allocate initial data@>=
@<allocate @code{bracket_expr}@>
@<allocate items@>
@

@<allocate @code{bracket_expr}@>=
BRACKET_EXPR *bracket_expr = (BRACKET_EXPR *) malloc(sizeof(BRACKET_EXPR));
if (bracket_expr == NULL) {
	snprintf(errbuf, errbuf_size, _("out of memory for expr"));
	return NULL;
}
memset(bracket_expr, 0, sizeof(BRACKET_EXPR));
@

@<allocate items@>=
#define INITIAL_SIZE 10
bracket_expr->items = (set_item *) malloc(INITIAL_SIZE * sizeof(set_item));
if (bracket_expr->items == NULL) {
	snprintf(errbuf, errbuf_size, _("out of memory for items"));
	goto fail;
}
memset(bracket_expr->items, 0, INITIAL_SIZE * sizeof(set_item));
bracket_expr->allocated = INITIAL_SIZE;
bracket_expr->nelems = 0;
bracket_expr->escapes_allowed = escapes_allowed;
bracket_expr->ignore_case = ignore_case;
bracket_expr->no_newlines = no_newlines;
bracket_expr->mb_cur_max = mb_cur_max;
@

We will come back to the various kinds of items such as @code{[:alpha:]} that
can occur inside brackets.  First, let's think about dealing with
regular characters and with simple ranges.

@node Handing ranges
@section Handling Ranges

We can have all kinds of weird cases, such as @code{[abcdapfedr-sz]}.
If this is reduced to the minimum, it becomes @code{[a-fpr-sz]}. We
need to be able to organize the (wide) characters such that we can
condense them down to this minimum sort of list.  To do that, we
first create a simple array of wide characters that we fill
one by one. In this case, the initial contents would be
@code{abcdapfedz}. The range @code{r-s} is added directly
to @code{bracket_expr->items} and is dealt with later.

Once the array of wide characters is built, we next sort it,
obtaining @code{aabcdefpz}. It can be uniqued and turned
into one or more ranges in the final step, yielding
first @code{abcdefpz} and finally @code{a-fpz}.

The range items will then be: @code{r-s}, @code{a-f}, @code{p-p} and
@code{z-z}. Another sorting pass yields @code{a-f}, @code{p-p},
@code{r-s} and @code{z-z}.
The sorted @code{RANGE_ITEM}s are then condensed by removing duplicates
and collapsing overlapping ranges.

First, we need some global data:

@<global data@>=
static wint_t *wide_chars = NULL;
static size_t wc_allocated = 0;
static size_t wc_inuse = 0;
@

Next, we need to allocate memory for the
array of wide characters, and initialize the memory.

@<allocate initial data@>=
@<allocate wide character array@>
@

@<allocate wide character array@>=
if (wide_chars == NULL) {	// first time through
	wide_chars = (wint_t *) malloc(INITIAL_SIZE * sizeof(wint_t));
	if (wide_chars == NULL) {
		snprintf(errbuf, errbuf_size, _("out of memory for wide characters"));
		goto fail;
	}
	wc_allocated = INITIAL_SIZE;
}
// always zero out the array, as we may have to make many BRACKET_EXPRs
memset(wide_chars, 0, wc_allocated * sizeof(wint_t));
wc_inuse = 0;
@

Next, we need a function to add a wide character
to the array. It's very straightforward:

@<helper functions@>=
/* push_wc --- add a wide character to the list */

static bool
push_wc(wint_t wc, char *errbuf, size_t errbuf_size)
{
	if (wc_inuse + 1 >= wc_allocated) {
		int new_amount = wc_allocated * 2;
		wint_t *new_data = (wint_t *) realloc(wide_chars, new_amount * sizeof(wint_t));

		if (new_data == NULL) {
			snprintf(errbuf, errbuf_size, _("out of memory for more wide characters"));
			return false;
		}
		memset(new_data + wc_allocated, 0, wc_allocated * sizeof(wint_t));
		wc_allocated = new_amount;
		wide_chars = new_data;
	}
	wide_chars[wc_inuse++] = wc;
	return true;
}
@

Once we have the list of wide characters, sorting it is easy:

@<sort wide character list@>=
qsort(wide_chars, wc_inuse, sizeof(wint_t), wint_compare);
@

@noindent
The comparison function is trivial:

@<item comparison functions@>=
/* wint_compare --- compare two wint values for qsort */

static int
wint_compare(const void *l, const void *r)
{
	wint_t *left = (wint_t *) l;
	wint_t *right = (wint_t *) r;

	return *left - *right;
}
@

Now some of the fun begins:

@<condense wide character list into @code{RANGE_ITEM}s@>=
@<remove duplicate wide characters@>
@<generate @code{RANGE_ITEM}s@>
@

Condensing the list simply shifts the characters down
as duplicates are found.  This is painful if there are
maybe thousands of duplicates but for typical regular
expressions, there shouldn't be any problem.

@<remove duplicate wide characters@>=
size_t i, j;
for (i = 0, j = 1; j < wc_inuse; i++, j++) {
	if (wide_chars[i] == wide_chars[j]) {
		for (int k = j + 1; k < wc_inuse; j++, k++) {
			wide_chars[j] = wide_chars[k];
		}
		wide_chars[j] = L'\0';

		wc_inuse--;
		j = i;
		i--;	// keep searching from same spot
	}
}
wide_chars[wc_inuse] = L'\0';	// not strictly necessary, but doesn't hurt
@

Once we have a sorted and uniqued list of wide characters,
generating the correct ranges is relatively easy.

@<generate @code{RANGE_ITEM}s@>=
size_t range_start, total;
range_start = total = 0;
for (i = 0, j = 1; j < wc_inuse; i++, j++) {
	if (wide_chars[j] == wide_chars[i] + 1) {	// ab...
		continue;
	} else if (wide_chars[j] > wide_chars[i] + 1) {
		// acd...
		// push a and start next range at c
		if (! push_range_item(bracket_expr, ignore_case,
				wide_chars[range_start], wide_chars[i], errbuf, errbuf_size))
			goto fail;
		total++;
		range_start = j;
	}
}
// Get any final range or character
if (wc_inuse > 0 && range_start <= wc_inuse - 1) {
	if (! push_range_item(bracket_expr, ignore_case,
				wide_chars[range_start], wide_chars[wc_inuse-1], errbuf, errbuf_size))
			goto fail;
	total++;
}
wc_inuse = total;
@

Pushing a range item is straightforward, similar to @code{push_wc()}
earlier.  There is one wrinkle, which is if we're ignoring case,
we have to allow both the uppercase and the lowercase version of each
character.

@<helper functions@>=
/* push_range_item --- add a range item to the expression */

static bool
push_range_item(BRACKET_EXPR *bracket_expr, bool ignore_case,
				wint_t first, wint_t last,
				char *errbuf, size_t errbuf_size)
{
	@<grow the set of items if necessary@>
	set_item new_item;
	new_item.item_type = RANGE_ITEM;
	if (ignore_case) {
		new_item.start = towupper(first);
		new_item.end = towupper(last);
		bracket_expr->items[bracket_expr->nelems++] = new_item;

		new_item.start = towlower(first);
		new_item.end = towlower(last);
		bracket_expr->items[bracket_expr->nelems++] = new_item;
	} else {
		new_item.start = first;
		new_item.end = last;
		bracket_expr->items[bracket_expr->nelems++] = new_item;
	}

	return true;
}
@

The logic for growing the set will be needed also when we
add @code{CTYPE_ITEM}s, so we factor it out:

@<grow the set of items if necessary@>=
if (bracket_expr->nelems + 1 >= bracket_expr->allocated) {
	size_t old_amount = bracket_expr->allocated;
	size_t new_amount = bracket_expr->allocated * 2;
	set_item *new_set = (set_item *) realloc(bracket_expr->items,
										new_amount * sizeof(set_item));
	if (new_set == NULL) {
		snprintf(errbuf, errbuf_size, _("no memory for more set items"));
		return false;
	}
	memset(new_set + old_amount, 0, old_amount * sizeof(set_item));
	bracket_expr->allocated = new_amount;
	bracket_expr->items = new_set;
}
@

@<condense final array of @code{set_item}s@>=
// sort it
qsort(bracket_expr->items, bracket_expr->nelems,
	sizeof(set_item), item_compare_for_sorting);

// condense it
items = bracket_expr->items;
for (i = 0, j = 1; j < bracket_expr->nelems; i++, j++) {
	if (   items[i].item_type == CTYPE_ITEM
		&& items[j].item_type == CTYPE_ITEM
		&& items[i].wtype == items[j].wtype) {
		free((void *) items[j].type_name);
		@<shift @code{items} down by one@>
	} else if (items[i].item_type != items[j].item_type) {
		continue;
	} else if (items[i].item_type == RANGE_ITEM) {
		@<condense overlapping ranges@>
	}
}
@

There are multiple possibilities for
overlapping ranges. For example, there's nothing stopping
someone from writing @code{[a-q12c-h]}, or @code{[bca123a-c]} or
almost anything else.  After sorting the various ranges, we
end up with the following possibilities:

@itemize @bullet
@item
Exact duplicate ranges:

@example
          +---+---+
item[i]   | a | d |        +---+---+
          +---+---+   ==>  | a | d |   item[i]
item[j]   | a | d |        +---+---+
          +---+---+
@end example

@noindent
The duplicate should be removed.

@item
Adjacent ranges.

@example
          +---+---+
item[i]   | a | d |                +---+---+
          +---+---+---+----   ==>  | a | h |   item[i]
item[j]           | e | h |        +---+---+
                  +---+---+
@end example

@noindent
The first range should be expanded to include the
end point of the second, and the second one should
be removed.

@item
Completely overlapping:

@example
          +----------+
item[i]   | abcdefhi |          +---+---+
          +----------+    ===>  | a | i |   item[i]
item[j]   |    def   |          +---+---+
          +----------+
@end example

@noindent
The second one should be removed.

@item
Partially overlapping on the left:

@example
          +----------+
item[i]   | abcdef   |         +---+---+
          +----------+    ===> | a | h |   item[i]
item[i]   |    defgh |         +---+---+
          +----------+
@end example

@noindent
Since ranges are sorted by @code{start}, we won't
have overlapping on the right.
Here too, the end point of the first range
should become that of the second, and
the second should be removed.
@end itemize

The following sequence of statements implements the logic:

@<condense overlapping ranges@>=
bool need_shift = false;
if (items[i].start == items[j].start && items[i].end == items[j].end) {
	need_shift = true;
} else if (items[i].end + 1 == items[j].start) {
	items[i].end = items[j].end;
	need_shift = true;
} else if (items[i].start < items[j].start && items[i].end > items[j].end) {
	need_shift = true;
} else if (   items[i].start <= items[j].start
           && items[i].end > items[j].start
           && items[j].end >= items[i].end) {
	items[i].end = items[j].end;
	need_shift = true;
}
if (need_shift) {
	@<shift @code{items} down by one@>
}
// otherwise, just continue around the loop
@

@<shift @code{items} down by one@>=
for (int k = j + 1; k < bracket_expr->nelems; j++, k++)
	items[j] = items[k];

bracket_expr->nelems--;
i--;	// compensate for loop, continue checking at current position
j = i + 1;
@

@node ctype items
@section Handling Character Classes Like @code{[:alpha:]}

Finally, it's time to deal with @code{[...[:alpha:]...]}.
POSIX allows for locales to have additional character classes
above and beyond the standard 12 classes available in every locale.
This means we have to ``nerd through'' the string to find the name,
copy it, and then look it up with with @code{wctype()}.  Sigh.

Even worse, since we're working with wide characters, we'll
have to convert what we find back to a multibyte string
before calling @code{wctype()}.

@<process @code{[:...:]} items@>=
if (cur_wchar == L':') {
	size_t count = 0;
	wctype_t the_type;
	const char *the_name = NULL;

	if (! find_ctype_info(cp, last - cp, & count, & the_type, & the_name,
			errbuf, errbuf_size, mb_cur_max, mbsp)) {
		if (the_name != NULL)
			free((void *) the_name);
		goto fail;
	}

	cp += count;
	if (! push_ctype_item(bracket_expr, ignore_case,
			the_type, the_name, errbuf, errbuf_size)) {
		if (the_name != NULL)
			free((void *) the_name);
		goto fail;
	}

	continue;
}
@

@<helper functions@>=
/* find_ctype_info --- fill in the info for a character class */

static bool
find_ctype_info(const char *cp, size_t len, size_t *count,
                wctype_t *the_type, const char **the_name,
                char *errbuf, size_t errbuf_size, size_t mb_cur_max,
                mbstate_t *mbsp)
{
	const char *begin = cp;
	const char *last = cp + len;
	char *name_buf;
	wchar_t *w_name_buf;
	wchar_t *namep = NULL;
	wint_t a_wchar;
	size_t n;
	bool invalid = false;

	w_name_buf = (wchar_t *) malloc((len + 1) * sizeof(wchar_t));
	if (w_name_buf == NULL) {
		snprintf(errbuf, errbuf_size, _("out of memory for character class name"));
		return false;
	}
	memset(w_name_buf, 0, (len + 1) * sizeof(wchar_t));

	for (namep = w_name_buf; cp < last;) {
		@<get a wide character@>
		if (a_wchar == L':') {
			break;
		}
		*namep++ = a_wchar;
	}

	*namep = L'\0';
	@<get a wide character@>
	if (a_wchar != L']') {
		snprintf(errbuf, errbuf_size, _("character class name %s missing closing \":]\""), name_buf);
		free(w_name_buf);
		return false;
	}
	*count = cp - begin;

	name_buf = (char *) malloc(len + 1);
	if (name_buf == NULL) {
		snprintf(errbuf, errbuf_size, _("out of memory for character class name"));
		free(w_name_buf);
		return false;
	}
	memset(name_buf, 0, len + 1);

	mbstate_t mbs;	// use a separate mbstate_t
	memset(& mbs, 0, sizeof(mbs));
	const wchar_t *name_start = w_name_buf;
	wcsrtombs(name_buf, & name_start, len + 1, & mbs);

	*the_type = wctype(name_buf);
	if (*the_type == 0) {	// not a known class name
		snprintf(errbuf, errbuf_size, _("unknown character class %s"), name_buf);
		free(w_name_buf);
		free(name_buf);
		return false;
	}
	*the_name = name_buf;
	free(w_name_buf);

	return true;
}
@

Pushing a @code{CTYPE_ITEM} is similar to pushing a @code{RANGE_ITEM}.
However, we have a lot of memory management details to worry about.

@<helper functions@>=
/* push_ctype_item --- add a ctype item to the expression */

static bool
push_ctype_item(BRACKET_EXPR *bracket_expr, bool ignore_case,
				wctype_t the_type, const char *the_name,
				char *errbuf, size_t errbuf_size)
{
	static bool first = true;
	static wctype_t lower, upper;
	static const char lower_s[] = "lower";
	static const char upper_s[] = "upper";

	if (first) {
		first = false;
		lower = wctype("lower");
		upper = wctype("upper");
	}

	@<grow the set of items if necessary@>
	set_item new_item;
	new_item.item_type = CTYPE_ITEM;
	if (ignore_case && (the_type == lower || the_type == upper)) {
		// lots of niggling details here...
		new_item.wtype = upper;
		new_item.type_name = strdup(upper_s);
		if (new_item.type_name == NULL) {
			snprintf(errbuf, errbuf_size, _("out of memory for character class name in item"));
			return false;
		}
		bracket_expr->items[bracket_expr->nelems++] = new_item;

		new_item.wtype = lower;
		new_item.type_name = strdup(lower_s);
		if (new_item.type_name == NULL) {
			snprintf(errbuf, errbuf_size, _("out of memory for character class name in item"));
			return false;
		}
		bracket_expr->items[bracket_expr->nelems++] = new_item;
		free((void *) the_name);
	} else {
		new_item.wtype = the_type;
		new_item.type_name = the_name;
		bracket_expr->items[bracket_expr->nelems++] = new_item;
	}

	return true;
}
@

@node Equivalence Classes and Collating Elements
@section Handling Equivalence Classes and Collating Elements

The first step for an equivalence class is to extract
the wide character and make sure it has the closing @samp{=]}.

@<process @code{[=...=]} items@>=
if (cur_wchar == L'=') {
	wint_t the_wc;
	const char *begin = cp;

	@<get current wide character@>
	the_wc = cur_wchar;

	@<peek at next wide character@>
	if (next_wchar != L'=') {
		snprintf(errbuf, errbuf_size, _("invalid equivalence class %.*s"), (int) ((cp + 1) - begin), begin);
		goto fail;
	}
	// consume the '='
	cp += n;
	@<peek at next wide character@>
	if (next_wchar != L']') {
		snprintf(errbuf, errbuf_size, _("invalid equivalence class %.*s"), (int) ((cp + 1) - begin), begin);
		goto fail;
	}
	// consume the ']'
	cp += n;

	if (! add_equivalent_characters(the_wc, errbuf, errbuf_size))
		goto fail;

	continue;
}
@

Here is Mike's portable but ``sleazy'' (sic) way to add all
the equivalent characters:

@<helper functions@>=
/* add_equivalent_characters --- do the work for [=X=] */

static bool
add_equivalent_characters(wint_t wc, char *errbuf, size_t errbuf_size)
{
	wchar_t wcs_in[2];
	wchar_t wcs[2];
	wchar_t abuf[100], wbuf[100];

	wcs_in[0] = wc;
	wcs_in[1] = 0;
	wcsxfrm(abuf, wcs_in, 99);
	wcs[1] = 0;
	for (wchar_t u = 1; u < 0x110000; ++u) {
		wcs[0] = u;
		wcsxfrm(wbuf, wcs, 99);
		if (abuf[0] == wbuf[0])
			if (! push_wc(u, errbuf, errbuf_size))
				return false;
	}

	return true;
}
@

@strong{FIXME:}
This is good for Unicode.  Eventually, we should figure out
if we're in a Unicode locale and do something different if not.
On the other hand, it's likely to work as-is for other
wide character sets as well. So maybe just leave it alone?

We allow single character collating elements:

@<process @code{[.X.]} items@>=
if (cur_wchar == L'.') {
	wint_t the_wc;
	const char *begin = cp;

	@<get current wide character@>
	the_wc = cur_wchar;

	@<peek at next wide character@>
	if (next_wchar != L'.') {
		snprintf(errbuf, errbuf_size, _("invalid collating element %.*s"), (int) ((cp + 1) - begin), begin);
		goto fail;
	}
	// consume the '.'
	cp += n;
	@<peek at next wide character@>
	if (next_wchar != L']') {
		snprintf(errbuf, errbuf_size, _("invalid collating element %.*s"), (int) ((cp + 1) - begin), begin);
		goto fail;
	}
	// consume the ']'
	cp += n;

	if (! push_wc(the_wc, errbuf, errbuf_size))
		goto fail;

	continue;
}
@

@node test driver
@chapter A Test Program And Driver

We need a test program, and a shell script to drive it:

@node test program
@section The Test Program

The test program builds a set and then compares one or more characters
against the set.  It takes several options:

@table @option
@item -F
Expect failure. Mutually exclusive with @option{-S}.

@item -S
Expect success. Mutually exclusive with @option{-F}.

@item -d
Dump the data structure.

@item -e
Escapes are allowed. By default they are not.

@item -i
Ignore case when matching. By default case is significant.

@item -q
Be quiet: don't print out what we're attempting match.
@end table

@(btest.c@)=
/* btest.c --- a test program for bracket_expr_create */

@<Copyright statement@>

@<main includes@>

@<usage function@>

/* main --- parse arguments, run the test */

int
main(int argc, char **argv)
{
	int i, c;
	wint_t wc;
	char *cp;
	bool expect_success = false, expect_failure = false;
	bool escapes_allowed = false, ignore_case = false;
	bool dump_data = false, quiet = false;

	@<parse command line arguments@>
	setlocale(LC_ALL, "");
	@<compile the expression@>
	@<test each wide character in the test case against the expression@>
	@<dump the data if needed@>

	return EXIT_SUCCESS;
}
@

@<main includes@>=
@<includes@>
#include <getopt.h>
#include "bracketexpr.h"
@

@<parse command line arguments@>=
int flags = 0;
while ((c = getopt(argc, argv, "SFdDeinq")) != -1) {
	switch (c) {
	case 'S':
		expect_success = true;
		break;
	case 'F':
		expect_failure = true;
		break;
	case 'd':
		dump_data = true;
		break;
	case 'D':
		flags |= SS_DOT;
		break;
	case 'e':
		flags |= SS_ESCAPES_ALLOWED;
		break;
	case 'i':
		flags |= SS_IGNORE_CASE;
		break;
	case 'n':
		flags |= SS_NO_NEWLINES;
		break;
	case 'q':
		quiet = true;
		break;
	case '?':
		usage(argv[0]);
		break;
	}
}

if (   (! expect_success && ! expect_failure)
    || (expect_success && expect_failure)) {
	fprintf(stderr, "You must give exactly one of -S or -F.\n");
	usage(argv[0]);
}
else if (optind + 2 > argc)	// no expr or no string provided
	usage(argv[0]);
@

@<usage function@>=
/* usage --- print a usage message and die */

static void
usage(const char *name)
{
	fprintf(stderr, "Usage: %s -S|-F [-deiq] '[bracket-expression]'" \
					" '<string of characters>'\n",
			name);
	fprintf(stderr, "\t-S\tExpect match success.\n");
	fprintf(stderr, "\t-F\tExpect failure of some kind.\n");
	fprintf(stderr, "\t-d\tDump the data structure.\n");
	fprintf(stderr, "\t-D\tMatch \"dot\" (any character).\n");
	fprintf(stderr, "\t-e\tEscapes are allowed.\n");
	fprintf(stderr, "\t-i\tIgnore case.\n");
	fprintf(stderr, "\t-n\tNo newlines in [^...] or \"dot\".\n");
	fprintf(stderr, "\t-q\tRun quietly.\n");
	exit(EXIT_FAILURE);
}
@

@<compile the expression@>=
char errbuf[BUFSIZ];
size_t errbuf_size = sizeof(errbuf);
const BRACKET_EXPR *bracket_expr;
const char *end;
mbstate_t mbs;
memset(& mbs, 0, sizeof(mbs));
bracket_expr = bracket_expr_create(argv[optind], strlen(argv[optind]), & end,
                   & mbs, flags, MB_CUR_MAX,
                   errbuf, errbuf_size);
if (bracket_expr == NULL && expect_success) {
	fprintf(stderr, "bad expression: %s\n", errbuf);
	// can't dump the data, return was NULL
	exit(EXIT_FAILURE);
}
@

@<test each wide character in the test case against the expression@>=
memset(& mbs, 0, sizeof(mbs));
if (! quiet)
	printf("expect %s: %s: %s\n", expect_success ? "success" : "failure",
			argv[optind], argv[optind+1]);

int mb_cur_max = MB_CUR_MAX;
for (cp = argv[optind + 1]; *cp != '\0';) {
	size_t count;
	bool isvalid = true;

	count = mbrtowc(& wc, cp, mb_cur_max, & mbs);
	if (count == (size_t) -1 || count == (size_t) -2) {
		count = 1;
		wc = *cp & 0xFF;
		cp++;	// skip over it and hope;
		memset(& mbs, 0, sizeof(mbs));	// reset the state
		isvalid = false;
	} else
		cp += count;

	bool matched = bracket_expr_match(bracket_expr, wc, isvalid);
	if (! matched && expect_success) {
		fprintf(stderr, "%s: failed to match L'%lc', success expected.\n", argv[optind], wc);
		@<dump the data if needed@>
		exit(EXIT_FAILURE);
	} else if (matched && expect_failure) {
		fprintf(stderr, "%s: succeeded to match L'%lc', failure expected.\n", argv[optind], wc);
		@<dump the data if needed@>
		exit(EXIT_FAILURE);
	}
}
@

@<dump the data if needed@>=
if (dump_data)
	bracket_expr_dump(bracket_expr, stdout);
@

@node test driver
@section The Test Program Driver Script

The idea is to have a text file containing tests, and a shell
script to read the tests and call @command{btest} appropriately.
The text file will have three columns separated by tabs:

@enumerate
@item
The command line options. At the very least one of @option{-F} or @option{-S}.

@item
The bracket expression.

@item
One or more characters to test against the bracket expression.
@end enumerate

Lines that start with @samp{#} are comment lines and are ignored, as are
empty lines.
We rely on Bash's special @code{$'@dots{}'} string notation to include TAB
characters instead of using physical TAB characters in the file.

@(runtests.sh@)=
#! /bin/bash

TESTFILE=${1:-testdata.txt}

sed -e $'/^[ \t]*#/d' -e $'/^[ \t]*$/d' $TESTFILE |
	while IFS=$'\t' read options expr chars
	do
		./btest $options "$expr" "$chars"
		echo
	done
@
@post_create runtests.sh chmod +x runtests.sh

We rely on the @file{Makefile} to save the results and compare them
to known good results.

For now, the test data is not included in this document.

@node Commentary
@chapter Commentary

@itemize @bullet
@item
The idea for the data structure was undoubtedly inspired by Russ Cox's
@code{libre2}, which uses a balanced binary tree of ranges for handling
bracket expressions.

In terms of searching, I expect the two data structures have the same
``big O'' complexity; my data structure saves the additional space overhead
of left and right subtree pointers.  Inserting into a balanced binary
tree is more complicated than my method of building the structure and then
sorting and uniquing it; however the binary tree won't insert something
that is already there.

In practice, I think it doesn't matter, as (a) most bracket expressions
are very simple and not pathological, and (b) when processing lots of
data, the amount of time spent building the data structure (compiling
the regular expression) gets lost down in the noise compared to the
amount of time spent executing it.

@item
One thing I've noticed a lot about Literate Programming is that
inlined chunks end up being used when more conventional programming
would dictate the use of a function (in C or @command{awk}) or
a macro (in C).  In particular, I sometimes miss the ability
to parameterize the objects a code chunk operates upon.

It then becomes a question: once the code is complete, should I
go back and modify things to use macros or functions? I think it
depends upon if the generated code will be what's maintained
going forward, or if the literate code will remain the main ``source''.
Thus, at least for now, the question remains open.
@end itemize

@node Code Chunk Summaries
@appendix Code Chunk Summaries

This @value{APPENDIX} presents alphabetical lists of
all the file definitions, the code chunk definitions,
and the code chunk references.

@menu
* File Definitions::          Source files by definition.
* Code Chunk Definitions::    Code chunks by definition.
* Code Chunk References::     Code chunks by reference.
@end menu

@node File Definitions
@appendixsec Source File Definitions

@print_file_defs

@node Code Chunk Definitions
@appendixsec Code Chunk Definitions

@print_code_defs

@node Code Chunk References
@appendixsec Code Chunk References

@print_code_refs

@node Concept Index
@unnumbered Index

@printindex cp

@bye

TODO:
